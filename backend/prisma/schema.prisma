// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------------------------
// -- NOUVELLE ARCHITECTURE MODULAIRE --
// ---------------------------------

// L'unité de base, la brique "Lego".
model PromptBlock {
  id        String          @id @default(cuid())
  name      String          // Nom du bloc pour l'UI (ex: "Rôle Expert React", "Tâche Dynamique")
  content   String          @db.Text // Contenu du bloc, peut contenir des variables (ex: "{{dynamic_task}}")
  
  // Le type de bloc détermine si un traitement spécial est nécessaire au backend.
  type      PromptBlockType @default(STATIC)
  
  // Pour l'organisation dans l'UI
  category  String?         // Catégorie définie par l'utilisateur (ex: "Rôles", "Instructions")
  color     String?         // Code couleur pour l'UI (ex: "#4299e1")

  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  // Relation: Un bloc peut appartenir à plusieurs compositions
  compositions PromptCompositionBlocks[]
}

// Enum pour les types de blocs spéciaux.
enum PromptBlockType {
  STATIC                   // Bloc de texte simple, copié/collé tel quel.
  DYNAMIC_TASK             // Un bloc spécial qui injectera la "demande finale" de l'utilisateur.
  PROJECT_STRUCTURE        // Un bloc qui déclenchera la génération de l'arborescence du projet.
  SELECTED_FILES_CONTENT   // Un bloc qui injectera le contenu des fichiers sélectionnés.
  PROJECT_INFO             // Un bloc qui injectera les informations du Workspace.
  // On pourra en ajouter d'autres plus tard ! (ex: GIT_DIFF, etc.)
}

// Un assemblage de blocs sauvegardé par l'utilisateur.
model PromptComposition {
  id        String    @id @default(cuid())
  name      String    @unique // Nom de l'assemblage (ex: "Prompt de Refactoring", "Générateur de Doc")
  
  // Relation via une table de jointure pour gérer l'ordre
  blocks    PromptCompositionBlocks[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relation: peut être le template par défaut pour plusieurs workspaces
  defaultForWorkspaces Workspace[]
}

// Table de jointure pour gérer l'ordre des blocs dans une composition
model PromptCompositionBlocks {
  id              String   @id @default(cuid())
  composition     PromptComposition @relation(fields: [compositionId], references: [id], onDelete: Cascade)
  compositionId   String
  block           PromptBlock @relation(fields: [blockId], references: [id], onDelete: Cascade)
  blockId         String
  order           Int      // L'ordre du bloc dans cette composition spécifique

  @@unique([compositionId, order])
}


// ---------------------
// -- MODÈLES ADAPTÉS --
// ---------------------

model Workspace {
  id                String   @id @default(cuid())
  name              String
  path              String   @unique
  selectedFiles     String[]
  lastFinalRequest  String?  @db.Text
  ignorePatterns    String[]
  projectInfo       String?  @db.Text
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Changement ici : on se lie à une Composition, pas à des Role/Format/Template
  defaultCompositionId String?
  defaultComposition   PromptComposition? @relation(fields: [defaultCompositionId], references: [id])
}

model Setting {
  id                  Int      @id @default(1)
  globalIgnorePatterns String[]
}
